#+TITLE: Go语言开发教程
* 目录
- [[#go语言基础][GO语言基础]]
- [[#函数][函数]]
- [[#面向对象编程][面向对象编程]]
- [[#多线程][多线程]]
- [[#日期与定时器][日期与定时器]]
- [[#文件操作][文件操作]]
- [[#json与xml解析][JSON与XML解析]]
- [[#mysql数据库操作][MySQL数据库操作]]
- [[#反射][反射]]
- [[#实现一个自己的orm][实现一个自己的ORM]]
- [[#tcp与udp网络编程][TCP与UDP网络编程]]
- [[#web编程][WEB编程]]
  
* GO语言基础
*** 第一个Go程序
    #+begin_src go
    package main
    import (
    "fmt"
    )
    func main() {
    fmt.Println("Hello World!")
    }
    #+end_src
    package 定义包(main)
    import 引入包(fmt)
    func 函数(main 主函数)
    Go所有字符串都是UTF-8编码,Go源文件采用UTF-8编码

*** 基本类型
    | <l>          |            |                                 |
    |--------------+------------+---------------------------------|
    | 类型         | 长度(字节) | 说明                            |
    |--------------+------------+---------------------------------|
    | bool         |          1 | true false.不能把非零值当作true |
    |--------------+------------+---------------------------------|
    | byte         |          1 | uint8 别名                      |
    |--------------+------------+---------------------------------|
    | rune         |          4 | int32 别名.代表一个Unicode字符. |
    |--------------+------------+---------------------------------|
    | int/uint     |          4 | 依据所运行的平台,32bit/64bit.   |
    |--------------+------------+---------------------------------|
    | int8/uint8   |          1 | -128~127   / 0 ~ 255            |
    |--------------+------------+---------------------------------|
    | int16/uint16 |          2 | -32768~32767;0~65535            |
    |--------------+------------+---------------------------------|
    | int32/uint32 |          4 | -21亿 ~ 21亿, 0 ~ 42亿          |
    |--------------+------------+---------------------------------|
    | complex64    |          4 | 复数类型,即32位实数+32位虚数    |
    |--------------+------------+---------------------------------|
    | complex128   |         16 | 复数类型,即64位实数+64位虚数    |
    |--------------+------------+---------------------------------|
    | uintptr      |            | 能够保存指针的32位或64位整数    |
    |--------------+------------+---------------------------------|
    | array        |            | 数组,值类型,如[2]int            |
    |--------------+------------+---------------------------------|
    | struct       |            | 结构体,值类型                   |
    |--------------+------------+---------------------------------|
    | slice        |            | 引用类型 如: []int              |
    |--------------+------------+---------------------------------|
    | map          |            | 引用类型                        |
    |--------------+------------+---------------------------------|
    | channel      |            | 引用类型                        |
    |--------------+------------+---------------------------------|
    | Interface    |            | 接口类型                        |
    |--------------+------------+---------------------------------|
    | function     |            | 函数类型                            |
    |--------------+------------+---------------------------------|

*** 定义变量
    Go语言里面定义变量有多种方式
    1) var n int //定义变量n
    2) var i int = 3 //定义变量i并赋值3
    3) var(

   aa int = 3

   str string="abcd"
)
    4) var i1,i2,i3 int=1,2,3
    5) var strName = "zhangsan"
    6) strSex := "男"
   #+BEGIN_SRC go -n
package main

import "fmt"

func main() {
	var b bool
	var n int
	var i int = 3
	var (
		aa  int = 3
		str string
	)
	var i1, i2, i3 int = 1, 2, 3
	var strName = "张三"
	strSex := "男"

	fmt.Println("n = ", n)
	fmt.Println("b ", b)
	fmt.Println("i=", i)
	fmt.Println("aa=", aa)
	fmt.Println("str=", str)
	fmt.Println("i1=", i1, "i2=", i2, "i3=", i3)
	fmt.Println("strName=", strName)
	fmt.Println("strSex=", strSex)
}

   #+END_SRC
*** array slice map 
**** 数组
     + array是固定长度的数组:
     *1.Go中的数组是值类型,如果将一个数组赋值给另外一个数组,
  实际上是将整个数组拷贝一份*
     *2.如果Go中的数组作为函数的参数,实际是传递参数的一份数组拷贝*
     *3.array的长度也是Type的一部分*

     + 数组声明:
  var arr_1 [2]int  //初始值为0

  arr_2 := [2]int{} //同上

  arr_3 := [2]int{1,2} //初始值{1,2}

  arr_4 := [...]int{1,2} //通过初始值判断大小

  arr_5 := [...]int{3:9} //声明有4个元素的数组,初始值为{0,0,0,9}
**** 切片 Slice
     Slice是引用类型,有点像指向数组的指针.
     []T是一个T类型的切片,切片不需要指定长度,指定长度就成了数组.
     #+BEGIN_SRC go
     package main

     import "fmt"
     import "reflect"

     func main() {
     p := [...]int{2, 3, 5, 7, 11, 13} //定义一个数组
     s1 := p[1:3]
     fmt.Println(s1)
     fmt.Println(reflect.TypeOf(p))
     fmt.Println(reflect.TypeOf(s1))
     ChangeArrayValue(p)
     fmt.Println(p)

     ChangeSliceValue(s1)
     fmt.Println(s1)
     fmt.Println(p)
     }

     func ChangeArrayValue(arr [6]int) {
     arr[0] = 100
     }
     func ChangeSliceValue(slice []int) {
     slice[0] = 100
     }

     #+END_SRC
**** Map
     map是一个key-value的hash结构,map的key必须支持比较运算符(== !=)的类型.
     Map用make来分配内存空间,make(map[TK]TV),TK是key的类型,TV是值的类型.
     #+BEGIN_SRC go 
     // Package main provides ...
     package main

     import (
     "fmt"
     )

     func main() {
     mp := make(map[string]string)
     mp["a"] = "1"
     mp["b"] = "2"
     mp["pi"] = "3.1415926"

     v, ok := mp["pi"]

     if ok {
     fmt.Println(v)
     } else {
     fmt.Println("Key sh 不存在")
     }

     }

     #+END_SRC
**** range 遍历
     Range可以对string array slice map channel进行迭代器操作.
     #+BEGIN_SRC go 
     // Package main provides ...
     package main

     import (
     "fmt"
     )

     func main() {
     arr := [3]int{1, 2, 3}
     var mp = map[int]string{1: "a", 2: "b", 3: "c"}
     for k, v := range mp {
     fmt.Println(k, " = ", v)
     }

     for _, v := range arr {
     fmt.Println(v)
     }
     }

     #+END_SRC
*** 常量
    c常量必须是编译器能确定的常量的定义使用const.
    const PI=3.1415926
    const(
    a = 12
    b = "bool"
    )
    const(
    a = iota //0
    b  //1
    c  //2
    d  //3
    e = iota
    f  //1
    )
*** 控制流
**** if else
     if a == b {
     ...
     }// else {
     ...
     }
**** switch
     默认带break
     switch i {
     case ex1:
     ...
     case ex2:
     ..
     case ex3:
     ...
     case ex4:
     fallthrough
     default:
     ...
     }
**** for 
     for init;condition;post{}
     for condition {}
     for {}
* 函数 
*** 函数定义
    可以多返回值 可变参
    func mymethod(args type) return1 type1, return2 type2...{}
*** defer
    延迟执行,按照后进先出的原则依次执行每一个defer注册的函数,
    保证资源释放,错误处理,清理数据.
*** 函数类型
    函数也是一种类型,拥有相同参数,相同返回值的函数,是同一种类型
    #+BEGIN_SRC go 

    // Package main provides ...
    package main

    import (
    "fmt"
    )

    type MyFuncType func(int) bool

    func IsBigThan5(n int) bool {
    return n > 5
    }
    func Display(arr []int, f MyFuncType) {
    for _, v := range arr {
    if f(v) {
    fmt.Println(v)
    }
    }
    }
    func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    Display(arr, IsBigThan5)
    }

    #+END_SRC
*** 错误处理
    Go语言中没有try...catch...finally这种结构化异常处理,
    而是panic代替throw抛出异常.使用recover函数来捕获异常.
    #+BEGIN_SRC go 

    // Package main provides ...
    package main

    import (
    "fmt"
    )

    func Test() {
    defer func() {
    if err := recover(); err != nil {
    fmt.Println(err)
    }
    }()
    divide(5, 0)
    fmt.Println("end of test")
    }

    func divide(a, b int) int {
    return a / b
    }
    func main() {
    Test()
    }

    #+END_SRC

*** 关于权限问题
    Go语言以大写开头的方法 变量 结构体 结构体属性为公共权限
* 面向对象编程
*** struct
    结构体是一种自定义类型,是不同数据的集合体struct的值类型.
    通常用定义一个抽象的数据对象
    type Object struct {
    Name string
    Age  int 
    ...
    }
*** 继承
    type Base struct {
    ...
    }
    type Case struct {
    Base
    ...
    }
*** Interface
    接口是一系列操作的集合,是一种约定.任何非接口类型只要拥有某个接口的全部方法,
    就表示它实现了该接口,Go中无需显示在该类上添加接口声明.
    #+BEGIN_SRC go

    // Package main provides ...
    package main

    import (
    "fmt"
    )

    type Student struct {
    Name  string
    Age   int
    class string
    }

    type IStudent interface {
    GetName() string
    GetAge() int
    }

    //通过Get方法,我们就可以说Student实现了IStudent接口
    func (this *Student) GetName() string {
    return this.Name
    }

    func (this *Student) GetAge() int {
    return this.Age
    }

    func main() {
    var s1 IStudent = &Student{"张三", 23, "2017(2)"}
    fmt.Println(s1.GetName)
    }


    #+END_SRC
* 多线程
*** 多线程
    线程是CPU调度的最小单位,只有不同的线程才能同时在多核CPU上同时运行.
    但线程太占资源,Go中的goroutine是一个轻量级的线程,执行时只需要4-5k的内存,
    比线程更易用,更高效,更轻便,调度开销比线程小,可同时运行上千万个并发.

    默认情况下,调度器仅使用单线程,要想发挥多核处理器的并发处理能力,必须调用
    runtime.GOMAXPROCS(n)来设置可并发的线程数,也可以通过环境变量GOMAXPROCS达到相同的目的.
    #+BEGIN_SRC go -n
    // Package main provides ...
    package main

    import (
    "fmt"
    "runtime"
    "time"
    )

    func SayHello() {
    for i := 0; i < 10; i++ {
    fmt.Print("Hello")
    runtime.Gosched() //释放CPU权限
    }
    }

    func SayWorld() {
    for i := 0; i < 10; i++ {
    fmt.Println("World!!")
    runtime.Gosched()
    }
    }

    func main() {
    fmt.Println(runtime.NumCPU()) //返回CPU核数
    fmt.Println(runtime.NumGoroutine()) //返回当前进程的Goroutime线程数
    go SayHello()
    go SayWorld()
    time.Sleep(5 * time.Second)
    }

    #+END_SRC
*** channel
    Goroutine之间通过channel来通信,可以认为channel是一个管道或先进先出的队列.
    可以从一个goroutine向channel发送数据,在另一个goroutine中取出这个值.
    #+BEGIN_SRC go -n
    // Package main provides 生产者/消费者是最经典的channel使用示例,
    //生产者goroutine负责将数据放入channel,消费者goroutine
    package main

    import (
    "fmt"
    )

    func producer(ch chan int) {
    defer close(ch) //关闭channel
    for i := 0; i < 10; i++ {
    ch <- i //阻塞,直到数据被消费者取走后才能发送下一条数据
    }
    }

    func consumer(c, f chan int) {
    for {
    if v, ok := <-c; ok {
    fmt.Println(v) //阻塞,直到生产者放入数据后继续取数据
    } else {
    break
    }
    }
    f <- 1
    }

    func main() {
    buf := make(chan int)
    flg := make(chan int)

    go producer(buf)

    go consumer(buf, flg)
    <-flg
    }


    #+END_SRC
    可以初始化带缓冲的channel
    ch := make(chan int, 10)
    监听多个channel时,使用select,随机处理一个可用channel
    #+BEGIN_SRC go 

    // Package main provides ...
    package main

    import (
    "fmt"
    )

    func Fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
    select {
    case c <- x:
    x, y = y, x+y
    case <-quit:
    fmt.Println("quit")
    return
    }
    }
    }
    func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
    for i := 0; i < 10; i++ {
    fmt.Println(<-c)
    }
    quit <- 0
    }()

    Fibonacci(c, quit)
    }
    #+END_SRC
    channel被read/write阻塞时,会一直阻塞下去,直到channel关闭,
    产生一个异常退出.通过select来实现channel超时机制.
    #+BEGIN_SRC go 
    // Package main provides ...
    package main

    import (
    "fmt"
    "time"
    )

    func main() {
    c := make(chan int)
    select {
    case <-c: //测试使用,没有向c发送任何数据,会一直阻塞
    fmt.Println("收到数据")
    case <-time.After(5 * time.Second):
    fmt.Println("超时退出")

    }
    }

    #+END_SRC
*** 进程同步
    互斥锁是线程间同步的一种机制,用来保证在同一个时刻只有一个线程访问共享资源.
    Go中的互斥锁在sync包中.
    #+BEGIN_SRC go 
    // Package main provides 一个线程安全的map
    package main

    import "errors"
    import "fmt"
    import "sync"

    type MyMap struct {
    mp    map[string]int
    mutex *sync.Mutex
    }

    func (this *MyMap) Get(key string) (int, error) {
    this.mutex.Lock()
    i, ok := this.mp[key]
    this.mutex.Unlock()
    if !ok {
    fmt.Println("不存在")
    return i, errors.New("不存在")
    }
    return i, nil
    }

    func (this *MyMap) Set(key string, v int) {
    this.mutex.Lock()
    defer this.mutex.Unlock()
    this.mp[key] = v
    }
    func (this *MyMap) Display() {
    this.mutex.Lock()
    defer this.mutex.Unlock()
    for k, v := range this.mp {
    fmt.Println(k, " = ", v)
    }
    }

    func SetValue(m *MyMap) {
    var a rune
    a = 'a'
    for i := 0; i < 10; i++ {
    m.Set(string(a+rune(i)), i)
     }
     }

     func main() {
     m := &MyMap{mp: make(map[string]int), mutex: new(sync.Mutex)}
     go SetValue(m)
     go m.Display()
     var str string
     fmt.Scan(&str)
     }

     #+END_SRC
* 日期与定时器
*** 日期的获取与计算
    Time包定义了所有时间相关的函数.获取当前时间用time.Now()
    #+BEGIN_SRC go 
    package main

    import (
    "fmt"
    "time"
    )

    func main() {
    fmt.Println(time.Now())
    //格式输出:2006-01-02 15:04:05
    fmt.Println(time.Now().Format("2006-01-02 15:04:05")) 
    }

    #+END_SRC 
    type Duration int64表示一个持续的时间,单位是纳米.
    多用于时间的加减、定时等操作需要传Duration作为参数.
    时间相加用Add,相减用Sub,时间的比函数有After,Equal,Before
    #+BEGIN_SRC go
    package main
    import (
    "fmt"
    "time"
    )
    func main() {
    t := time.Now()
    t2 := time.Add(24*time.Hour)
    d := t2.Sub(t)
    fmt.Println(t)
    fmt.Println(t2)
    fmt.Println(d)

    if t.Before(t2) {
    fmt.Println("t < t2")
    }
    if t.After(t) {
    fmt.Println("t2 > t")
    }
    if t.Equal(t2) {
    fmt.Println(t == t2)
    }
    }
    #+END_SRC

* 文件操作
*** 路径
     func Base(path string) string 返回路径的最后一部分
     #+BEGIN_SRC go

     package main

     import (
     "fmt"
     "path"
     "strings"
     )

     func main() {
     fmt.Println(path.Base("/usr/bin"))
     fmt.Println(path.Base(""))
     fmt.Println(path.Base("C:\\Windows"))
     fmt.Println(path.Base(strings.Replace("C:\\Windows", "\\", "/", -1)))
     }
     #+END_SRC
*** 文件读写
func Create(name string) (file *File, err error)
创建新文件,如果文件已存在,将被截断.新建的文件是可读写的,默认权限为0666
func Open(name string)(file *File, err error)
打开已存在的文件,用来读取文件内容.Open打开的文件是只读的,不能写.
func OpenFile(name string, flag int, perm FileMode)(file *File, err error)
OpenFile是一个通用的函数,可以用来创建文件,以只读方式打开文件,以读写方法打开文件等.
Name是要打开或创建的文件名;flag是打开文件的方式,以只读方式或读写方式
flag取值:
| O_RDONLY | 以只读方式打开文件                              |
| O_WRONLY | 以只写方式打开文件                              |
| O_RDWR   | 以读写方式打开文件                              |
| O_APPEND | 以追加方式打开文件,写入的数据将追加到文件尾     |
| O_CREATE | 当文件不存在时创建文件                          |
| O_EXCL   | 与O_CREATE一起使用,当文件已经存在时Open操作失败 |
| O_SYNC   | 以同步方式打开文件                              |
| O_TRUNC  | 如果文件已存在,打开时将会清空文件内容.必须与O_WRONLY或O_RDWR配合使用        |

FileMode参数是文件的权限,只有在文件不存在,新创建文件时该参数才有效.
用来指定新建的文件的权限,必须跟O_CREATE配合使用
#+BEGIN_SRC go 
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	f, err := os.OpenFile("新建文本文档.txt", os.O_CREATE|os.O_RDONLY|os.O_APPEND|os.O_WRONLY, 0666)

	if err != nil {
		fmt.Println(err.Error())
		return
	}
	defer f.Close()
	f.WriteString("\r\n中国好\r\n")
	buf := make([]byte, 1024)

	var str string
	f.Seek(0, os.SEEK_SET) //重置文件指针到开始位置

	for {
		n, ferr := f.Read(buf)
		if ferr != nil && ferr != io.EOF {
			fmt.Println(ferr.Error())
			break
		}
		if n == 0 {
			break
		}
		fmt.Println(n)
		str += string(buf[0:n])
	}
	fmt.Println(str)
}

#+END_SRC
*** 遍历目录下的文件
OpenFile除了可以打开文件,还可以打开一个目录,在File对象有一个
Readdir函数,用来读取某个目录下的所有文件和目录信息,位于OS包中
func (f *File)Readdir(n int)(fi []FileInfo, err error)
#+BEGIN_SRC go
package main

import (
	"fmt"
	"os"
)

func main() {
	f, err := os.OpenFile("/usr/bin", os.O_RDONLY, 0666)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	defer f.Close()
	arrFile, err1 := f.Readdir(0)
	if err1 != nil {
		fmt.Println(err1.Error())
		return
	}

	for k, v := range arrFile {
		fmt.Println(k, "\t", v.Name(), "\t", v.IsDir())
	}
}

#+END_SRC
*** 序列化
序列化就是将对象的状态信息转化为可以存储或传输的形式的过程.
在序列化期间,对象将其当前的状态写入到临时或持久性存储区.
之后,可以通过从存储区中读取或反序列化对象的状态,重新创建该对象.
Gob是Go中所特用的序列化技术,它支持除了interface,function,channel外
的所有Go数据类型.序列化使用Encoder,反序列化使用Decoder.
#+BEGIN_SRC go
package main

import (
	"encoding/gob"
	"fmt"
	"os"
)

type Student struct {
	Name string
	Age  int
}

func main() {
	s := &Student{Name: "张三", Age: 19}
	f, err := os.Create("data.dat")

	if err != nil {
		fmt.Println(err.Error())
		return
	}
	defer f.Close()

	//创建Encoder对象
	encode := gob.NewEncoder(f)
	encode.Encode(s)

	f.Seek(0, os.SEEK_SET)
	decoder := gob.NewDecoder(f)
	var s1 Student

	decoder.Decode(&s1)
	fmt.Println(s1)
}

#+END_SRC
* JSON与XML解析
*** XML序列化与解析
Xml作为一种平台无关的数据交换和信息传递技术应用十分广泛.
Go中提供XML序列化的文法位于encoding/xml包中.
func (enc *Encoder) Encode(v interface{}) error
 可以从一个对象直接序列化到io.Writer对象中.
func (d *Decoder) Decode(v interface{}) error 从
io.Reader中,反序列化xml
#+BEGIN_SRC go 
package main

import (
	"encoding/xml"
	"fmt"
	"os"
)

type Student struct {
	Name string
	Age  int
}

func main() {
	f, err := os.Create("data.dat")
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	defer f.Close()
	s := &Student{Name: "张三111", Age: 19}
	encoder := xml.NewEncoder(f)
	encoder.Encode(s)

	f.Seek(0, os.SEEK_SET)

	decoder := xml.NewDecoder(f)
	var s1 Student

	decoder.Decode(&s1)
	fmt.Println(s1)
}

#+END_SRC
*** xml包的Marshal函数可以把一个对象直接序列化成字符
#+BEGIN_SRC go 
package main

import (
	"encoding/xml"
	"fmt"
)

type Student struct {
	Name string
	Age  int
}

func main() {
	s := &Student{Name: "张三", Age: 19}
	result, err := xml.Marshal(s)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	fmt.Println(string(result))
}

#+END_SRC
*** UnMarshal将一个xml反序列化为对象
#+BEGIN_SRC go 
package main

import (
	"encoding/xml"
	"fmt"
	"os"
)

type Student struct {
	Name string
	Age  int
}

func main() {
	f, err := os.Open("data.dat")
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	defer f.Close()
	buf := make([]byte, 1024)
	n, err := f.Read(buf)
	fmt.Println(buf[0:n])
	str := string(buf[0:n])

	var s Student
	xml.Unmarshal(buf[0:n], &s)
	fmt.Println(s)
	xml.Unmarshal([]byte(str), &s)
	fmt.Println(s)
}

#+END_SRC
在反序列化XML "<Student><Name>张三</Name><Age>19</Age></Student>"时,
结构体名称跟<Student>对应,字段名Name,与<Name>对应,
结构体中的字段必须是公有的,即大写字母开头.如果要解析的xml是小写的,
可以使用tag来指定Struct的字段与xml标记的对应关系.
#+BEGIN_SRC go
package main

import (
	"encoding/xml"
	"fmt"
)

type Student struct {
	XMLName string `xml:"student"`
	Name    string `xml:"name"`
	Age     int    `xml:"age"`
}

type ABC string

func main() {
	str := `<?xml version="1.0" encoding="utf-8"?>
<student>
<name>张三</name>
<age>19</age>
</student>`

	var s Student

	xml.Unmarshal([]byte(str), &s)
	fmt.Println(s)
}

#+END_SRC
对于大文件解析,或对性能有要求时,使用Token解析
#+BEGIN_SRC go
package main

import (
	"encoding/xml"
	"fmt"
	"strings"
)

type Student struct {
	Name string `xml:"name"`
	Age  int    `xml:"age"`
}

type ABC string

func main() {
	str := `<?xml version="1.0" encoding="utf-8"?>
<student>
<name>张三</name>
<age>19</age>
</student>`

	decoder := xml.NewDecoder(strings.NewReader(str))
	var strName string
	for {
		token, err := decoder.Token()
		if err != nil {
			break
		}
		switch t := token.(type) {
		case xml.StartElement:
			stelm := xml.StartElement(t)
			fmt.Println("Start ", stelm.Name.Local)
			strName = stelm.Name.Local
		case xml.EndElement:
			endelem := xml.EndElement(t)
			fmt.Println("End ", endelem.Name.Local)
		case xml.CharData:
			data := xml.CharData(t)
			str := string(data)
			switch strName {
			case "Name":
				fmt.Println("姓名: ", str)
			case "Age":
				fmt.Println("年龄: ", str)
			default:
				fmt.Println("other: ", str)
			}
		}
	}
	var s Student

	xml.Unmarshal([]byte(str), &s)
	fmt.Println(s)
}

#+END_SRC
*** JSON序列化与反序列化
Json是一种比XML更轻量级的数据交换格式,易于人们阅读和编写,也易于程序解析和生成.
#+BEGIN_SRC go 
package main

import (
	"encoding/json"
	"fmt"
	"os"
)

type Student struct {
	Name string
	Age  int
}

func main() {
	f, err := os.Create("data.dat")
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	defer f.Close()

	s := &Student{Name: "张三", Age: 19}

	encoder := json.NewEncoder(f)
	encoder.Encode(s)

	f.Seek(0, os.SEEK_SET)
	decoder := json.NewDecoder(f)
	var s1 Student
	decoder.Decode(&s1)
	fmt.Println(s1)
}

#+END_SRC
同样Json也提供了Marshal,Unmarshal,对于结构体可以使用`json:"JsonName"`
来指定解/编码时对应的json名称.
#+BEGIN_SRC go
package main

import (
	"encoding/json"
	"fmt"
)

type Student struct {
	Name string `json:"username"`
	Age  int
}

func main() {
	s := &Student{Name: "张三", Age: 19}

	buf, err := json.Marshal(s)
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	fmt.Println(string(buf))
	var s1 Student
	err = json.Unmarshal(buf, &s1)
	if err != nil {
		fmt.Println(err.Error())
	}
	fmt.Println(s1)
}

#+END_SRC

* MySQL数据库操作
*** 安装MySQL驱动
在实际应用中数据库操作是经常用到的.Go提供了database/sql,database/driver两个包.
database/driver定义了一些标准的接口,这些接口由具体的数据库驱动程序实现,Go官方没有
提供具体的驱动程序,仅提供了接口,驱动程序由第三方实现.
MySQL常用驱动:[[https://github.com/go-sql-driver/mysql][mysql驱动]]
go get github.com/go-sql-driver/mysql
go install github/go-sql-driver/mysql 
*** MySQL数据库操作
func Open(driverName, dataSourceName string)(*DB, error)
根据driverName打开指定的数据库.driverName驱动的名称,dataSourceName通常包含了
数据库名,和链接信息,如服务器地址、用户名、密码等。
+ func (db *DB)Exec(query string, args ...interface{})(Result, error)
执行一个SQL查询,不返回任何行.通常用来执行数据的插入,更新操作.query是要执行的SQL
语句,args是参数,执行成功error为nil,Result是一个接口,定义如下:
#+BEGIN_SRC  go
type Result interface {
   LastInsertId()(int64, error)
   RowsAffected()(int64, error)
}
#+END_SRC
LastInsertId返回最后一次自动长列的值,RowsAffected返回所影响的行.
+ func (db *DB)Query(query string, args ...interface{})(*Rows,error)
执行SQL,并返回数据行.
+ func (r *Row)Scan(dest ...interface{}) error
用来从返回的数据中,取数据.
#+BEGIN_SRC go
var id int
var name string
row.Scan(&id, &name)
#+END_SRC

+ func (db *DB)QueryRow(query string, args ...interface{}) *Row
与Query类似,唯一的区别是,该函数只返回一条数据
实例:
#+BEGIN_SRC sql
Drop table if exists person;
create table person (
id int(11) not null auto_increment,
name varchar(255) default null,
age int(11) default null,
IsBoy tinyint(4) default null,
primary key (id)
) default charset=utf8;

#+END_SRC
#+BEGIN_SRC go 
package main

import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
)

func main() {
	db, err := sql.Open("mysql", "root:root@tcp(127.0.0.1:3306)/sampledb?charset=utf8")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer db.Close()
	var result sql.Result

	result, err = db.Exec("insert into person(name, age, IsBoy) values(?,?,?)", "张三", 19, true)
	if err != nil {
		fmt.Println(err)
		return
	}

	lastId, _ := result.LastInsertId()
	fmt.Println("新插入的数据ID为: ", lastId)
	var row *sql.Row

	row = db.QueryRow("select * from person")
	var name string
	var id, age int
	var isBoy bool
	err = row.Scan(&id, &name, &age, &isBoy)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(id, "\t", name, "\t", age, "\t", isBoy)

	result, err = db.Exec("insert into person(name, age, IsBoy) values(?, ?, ?)", "王红", 18, false)
	fmt.Println("---------------")
	var rows *sql.Rows
	rows, err = db.Query("select * from person")
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	for rows.Next() {
		var name string
		var id, age int
		var isBoy bool
		rows.Scan(&id, &name, &age, &isBoy)
		fmt.Println(id, "\t", name, "\t", age, "\t", isBoy)
	}

	rows.Close()
	//清空表
	//db.Exec("truncate table person")
}
#+END_SRC

+ func (db *DB)Prepare(query string)(*Stmt, error)
对SQL语句进行预处理,并返回*Stmt类型.Prepare方法主要用于对行重复性的操作,如循环插入10000条数据.
#+BEGIN_SRC go
package main

import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"math/rand"
	"time"
)

func main() {
	db, err := sql.Open("mysql", "root:root@tcp(127.0.0.1:3306)/sampledb?charset=utf8")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer db.Close()

	var stmt *sql.Stmt
	stmt, err = db.Prepare("insert into person(name, age, IsBoy) values(?,?,?)")

	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("开始插入数据...", time.Now())
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	for i := 0; i < 10000; i++ {
		_, err = stmt.Exec(fmt.Sprintf("张%d", r.Int()), r.Intn(50), r.Intn(100)%2)
		if err != nil {
			fmt.Println(err)
			return
		}
	}
	fmt.Println("数据插入完成...", time.Now())
}

#+END_SRC
*** 事务
事务是编程中最小的执行单元,它的代码要么全部成功,要么全部失败,不能部分成功/失败.
#+BEGIN_SRC go 
func (db *DB)Begin() (*Tx, error) //开始一个事务
func (tx *Tx)Commit() error  //提交事务
func (tx *Tx)Rollback() error //回滚一个事务
#+END_SRC
示例:
#+BEGIN_SRC go
package main

import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
)

func main() {
	db, err := sql.Open("mysql", "root:root@tcp(127.0.0.1:3306)/sampledb?charset=utf8")
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	defer db.Close()
	var trans *sql.Tx
	trans, err = db.Begin()
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	_, err = trans.Exec("insert into person (name, age, IsBoy) values('张三',77, false)")
	if err != nil {
		trans.Rollback()
	} else {
		trans.Commit()
	}
}

#+END_SRC
* 反射
*** 反射基础
反射是审查元数据并收集关于它的类型信息的能力.
#+BEGIN_SRC go
func TypeOf(i interface{}) Type //返回i的类型信息,如果i为nil,返回nil,Type是一个接口
#+END_SRC
Type接口定义
#+BEGIN_SRC go
type Type interface{
 Name() string 
 PkgPath() string
 ....
}
#+END_SRC
*** 反射调用函数
TypeOf,ValueOf都可以对函数进行调用,区别在于,使用TypeOf时,函数的第一个参数是结构体本身,
需要把结构体自身作为输入参数传递,而ValueOf不需要这样.
#+BEGIN_SRC go
package main

import (
	"fmt"
	"reflect"
)

type Student struct {
	Name string
	Age  int
}

func (this *Student) PrintName() {
	fmt.Println(this.Name)
}
func (this *Student) GetAge() int {
	return this.Age
}

func main() {
	s := &Student{Name: "abc", Age: 19}
	rt := reflect.TypeOf(s)//如果是引用&,会产生恐慌  
	rv := reflect.ValueOf(s)//如果是引用&,会产生恐慌
	fmt.Println("Typeof 调用函数")
	rtm, ok := rt.MethodByName("PrintName")
	if ok {
		var parm []reflect.Value
		parm = append(parm, rv)
		rtm.Func.Call(parm)
	}
	//valueof调用函数
	fmt.Println("valueof调用函数")

	rvm := rv.MethodByName("GetAge")
	//用valueof调用函数时不需要把Struct本身作为参数传递过去
	ret := rvm.Call(nil)
	//显示返回值
	fmt.Println("返回值")
	ShowSlice(ret)
}

func ShowSlice(s []reflect.Value) {
	if s != nil && len(s) > 0 {
		for _, v := range s {
			fmt.Println(v.Interface())
		}
	}
}

#+END_SRC
*** 反射取Struct的Tag信息
可以对结构体进行反射时取tag附加信息.
#+BEGIN_SRC go
package main

import (
	_ "encoding/json"
	"fmt"
	"reflect"
)

type Student struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	s := Student{Name: "aaa", Age: 19}
	rt := reflect.TypeOf(s)
	filedName, ok := rt.FieldByName("Name")
	//取tag数据
	if ok {
		fmt.Println(filedName.Tag.Get("json"))
	}
	fileAge, ok := rt.FieldByName("Age")
	if ok {
		fmt.Println(fileAge.Tag.Get("json"))
	}
}

#+END_SRC

* 实现一个自己的ORM
*** 实现自己的ORM
一个简单的orm,只实现Insert,Update,Delete,Load几个方法.
通常向数据库插入数据时,只要Insert(model),不需要写SQL代码,
model是struct结构体,在Insert的内部,利用反射,来取得结构体
的名称做表名,结构体的字段作为数据表的字段名,结构体的字段值
作为数据表的字段值,或者根据tag值来确定对应关系.
#+BEGIN_SRC go
type Person struct {
	//TableName类型只是用来设置表名.如果结构体名跟表名相同可以忽略
	TableName SimpleDb.TableName "person"
	//PK用来设置是否主键
	Id int `name:"id"PK:"true"Auto:"true"`
	Name string "name" //对应表中的name值
	Age int "age"
	IsBoy bool
	NotUse string "-"
}
#+END_SRC

* TCP与UDP网络编程
*** TCP编程
TCP即传输控制协议/网间协议,是一种面向连接(连接导向)的,可靠的,
基于字节流的一个端到端(Peer-to-Peer)的传输层协议.

Go的net包提供了对Tcp操作的支持
+ func InterfaceAddrs()([]Addr, error)返回本机的网络地址列表
#+BEGIN_SRC go
// Package main provides ...
package main

import (
	"fmt"
	"net"
)

func main() {
	addr, err := net.InterfaceAddrs()

	if err != nil {
		fmt.Println(err.Error())
		return
	}
	fmt.Println(addr)
}
#+END_SRC
+ func LookupIP(host string)(addrs []IP, err error)用来获取主机所对应的IP地址.
IP是一个[]byte类型,用来表示一个IP地址. type IP []byte 
#+BEGIN_SRC go
// Package main provides ...
package main

import (
	"fmt"
	"net"
)

func main() {
	ips, err := net.LookupIP("www.baidu.com")

	if err != nil {
		fmt.Println(err.Error())
		return
	}
	fmt.Println(ips)
}
#+END_SRC
+ func ResolveTCPAddr(net, addr string) (*TCPAddr, os.Error)
该函数用来创建一个TCPAddr,第一个参数为:tcp/tcp4/tcp6,addr是一个字符串,
由主机名或IP地址以及":"后端口号组成.TCPAddr定义:
#+BEGIN_SRC go
type TCPAddr struct {
IP IP 
Port int 
}
#+END_SRC
示例:
#+BEGIN_SRC go
// Package main provides ...
package main

import (
	"fmt"
	"net"
)

func main() {
	ip, err := net.ResolveTCPAddr("tcp", "www.baidu.com:80")

	if err != nil {
		fmt.Println(err.Error())
		return
	}
	fmt.Println(ip)
}
#+END_SRC
+ func ListenTCP(net string, laddr *TCPAddr)(*TCPListener, error)
TCP程序分为服务端和客户端.服务端程序在某一个端口监听客户端的链接请求,有客户端的连接请求时,
读取客户端发来的数据,进行相关的处理,然后关闭链接.ListenTCP函数用于监听指定的端口,
等待客户端的链接.
+ func (l *TCPListener)AcceptTCP()(*TCPConn, error)
用来接受客户端的请求,返回一个Conn链接,通过这个Conn来与客户端进行通信.
+ func (l *TCPListener) Accept()(Conn, error)
与AcceptTCP相同
+ func (c *TCPConn)Write(b []byte)(int, error)
向TCPConn网络链接发送数据,b是要发送的内容,返回值int为实际发送的字节数.
+ func (c *TCPConn)Read(b []byte) (int, error)
从TCPConn网络链接接收数据,返回值为实际接收的字节数,b是接收的数据.
+ func DialTCP(net string,laddr, raddr *TCPAddr)(*TCPConn, error)
用来链接远程服务器.net可以是tcp/tcp4/tcp6中的一个,Laddr为本地地址,通常为null,
raddr链接的远程服务器地址.成功返回TCPConn,用返回的TCPConn可以向服务器发送消息,
读取服务器的响应信息.
*** TCP编程实战
实现一个简单的程序,客户端向服务端发送ls列出当前目录下的文件,发送cd命令来改变当前目录.
服务端收到客户端的命令后,进行相关的处理.并将结果发送给客户端.
服务端:
#+BEGIN_SRC go
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net"
	"os"
)

const (
	LS  = "LS"
	CD  = "CD"
	PWD = "PWD"
)

func main() {
	//转换地址
	//监听7070端口
	tcpAddr, err := net.ResolveTCPAddr("tcp", ":7070")
	checkError(err)
	listener, err := net.ListenTCP("tcp", tcpAddr)
	checkError(err)
	for {
		//等待客户端链接
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println(err.Error())
			continue
		}
		fmt.Println("收到客户端的请求")
		go ServeClient(conn)
	}
}
func ServeClient(conn net.Conn) {
	defer conn.Close()
	str := ReadData(conn)
	if str == "" {
		SendData(conn, "接收数据时出错")
		return
	}
	fmt.Println("收到命令: ", str)
	switch str {
	case LS:
		ListDir(conn)
	case PWD:
		Pwd(conn)
	default:
		if str[0:2] == CD {
			Chdir(conn, str[3:])
		} else {
			SendData(conn, "命令错误")
		}
	}
}

//修改目录
//使用os.Chdir
func Chdir(conn net.Conn, s string) {
	err := os.Chdir(s)
	if err != nil {
		SendData(conn, err.Error())
	} else {
		SendData(conn, "OK")
	}
}

//列出当前目录下的文件
func ListDir(conn net.Conn) {

	files, err := ioutil.ReadDir(".")
	if err != nil {
		SendData(conn, err.Error())
		return
	}
	var str string
	for i, j := 0, len(files); i < j; i++ {
		f := files[i]
		str += f.Name() + "\t"
		if f.IsDir() {
			str += "dir\r\n"
		} else {
			str += "file\r\n"
		}
	}
	SendData(conn, str)
}

//读取数据
func ReadData(conn net.Conn) string {
	var data bytes.Buffer
	var buf [512]byte
	for {
		n, err := conn.Read(buf[0:])
		if err != nil {
			fmt.Println(err)
			return ""
		}
		if buf[n-1] == 0 {
			data.Write(buf[0 : n-1])
			break
		} else {
			data.Write(buf[0:n])
		}
	}
	return string(data.Bytes())
}

//发送数据
func SendData(conn net.Conn, data string) {
	buf := []byte(data)
	buf = append(buf, 0) //以0作为结束标记
	_, err := conn.Write(buf)
	if err != nil {
		fmt.Println(err)
	}
}

// Pwd
func Pwd(conn net.Conn) {
	s, err := os.Getwd()
	if err != nil {
		SendData(conn, err.Error())
	} else {
		SendData(conn, s)
	}
}
func checkError(err error) {
	if err != nil {
		fmt.Println(err.Error())
		return
	}
}
#+END_SRC
客户端 
#+BEGIN_SRC go
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"net"
	"os"
	"strings"
)

const (
	LS   = "LS"
	CD   = "CD"
	PWD  = "PWD"
	QUIT = "QUIT"
)

func main() {

	reader := bufio.NewReader(os.Stdin)
	for {
		fmt.Println("请输入命令: ")
		line, err := reader.ReadString('\n')
		checkError(err)
		//去掉两端的空格
		line = strings.TrimSpace(line)
		//转换为大写
		line = strings.ToUpper(line)
		//转化为数组
		arr := strings.SplitN(line, " ", 2)
		fmt.Println(arr)

		switch arr[0] {
		case LS:
			SendRequest(LS)
		case CD:
			SendRequest(CD + " " + strings.TrimSpace(arr[1]))
		case PWD:
			SendRequest(PWD)
		case QUIT:
			fmt.Println("程序退出")
			return
		default:
			fmt.Println("命令错误")
		}
	}
}

func SendRequest(cmd string) {
	tcpAddr, err := net.ResolveTCPAddr("tcp", "127.0.0.1:7070")
	checkError(err)
	conn, err := net.DialTCP("tcp", nil, tcpAddr)
	checkError(err)
	SendData(conn, cmd)
	fmt.Println(ReadData(conn))
}

//读取数据
func ReadData(conn net.Conn) string {
	var data bytes.Buffer
	var buf [512]byte
	for {
		n, err := conn.Read(buf[0:])
		if err != nil {
			fmt.Println(err)
			return ""
		}
		if buf[n-1] == 0 {
			data.Write(buf[0 : n-1])
			break
		} else {
			data.Write(buf[0:n])
		}
	}
	return string(data.Bytes())
}

//发送数据
func SendData(conn net.Conn, data string) {
	buf := []byte(data)
	buf = append(buf, 0) //以0作为结束标记
	_, err := conn.Write(buf)
	if err != nil {
		fmt.Println(err)
	}
}

func checkError(err error) {
	if err != nil {
		fmt.Println(err.Error())
		return
	}
}
#+END_SRC
TCP协议需要通信双方约定数据的传输格式,否则接收方无法判断是否接收完成.
*** UDP网络编程
UDP是用户数据报协议(User Datagram Protocol,UDP)的简称,UDP协议提供
的是面向无连接的,不可靠的数据报传输服务.
+ func ResolveUDPAddr(net, addr string)(*UDPAddr, error)
解析addr字符串为UDPAddr地址，net是udp/udp4/udp6,
+ func ListenUDP(net string laddr *UDPAddr)(*UDPConn, error)
在指定的地址(laddr)监听,等待UDP数据包的到达.返回*UDPConn,
可以使用连接的ReadFrom函数来读取UDP数据.用WriteTo来向客户端发送数据.
+ func (c *UDPConn)ReadFrom(b []byte)(int, Addr, error)
服务器用来读取UDP数据，Addr是发送的地址。
+ func (c *UDPConn)WriteTo(b []byte, addr Addr)(int, error)
向addr写入数据，b是要发送的内容，addr是接收的地址。
+ func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)
连接到远端服务器raddr，laddr通常为nil，如果不是nil，将使用laddr连接到服务端
+ func (c *UDPConn) Write(b []byte)(int, error)
用来向服务器发送数据
+ func (c *UDPConn)ReadFromUDP(b []byte)(n int, addr *UDPAddr, err error)
与ReadFrom相同，用来读取UDP数据

实例：
服务端：
#+BEGIN_SRC go
package main

import (
	"fmt"
	"net"
)

func main() {
	//转换地址
	addr, err := net.ResolveUDPAddr("udp", ":7070")
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	//监听7070端口
	conn, err := net.ListenUDP("udp", addr)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	//循环读取数据
	for {
		var buf [1024]byte
		n, caddr, err := conn.ReadFromUDP(buf[0:]) //返回的是客户端的地址
		if err != nil {
			fmt.Println(err)
			return
		}

		go HandleClient(conn, buf[0:n], caddr)
	}
}

func HandleClient(conn *net.UDPConn, data []byte, addr *net.UDPAddr) {
	fmt.Println("接收到的数据: " + string(data))
	conn.WriteToUDP([]byte("OK, 数据以收到"), addr)
}
#+END_SRC
客户端:
#+BEGIN_SRC go
package main

import (
	"fmt"
	"net"
)

func main() {
	//转换地址
	addr, err := net.ResolveUDPAddr("udp", "127.0.0.1:7070")
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	//连接到服务端
	conn, err := net.DialUDP("udp", nil, addr)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	defer conn.Close()

	//简单写入数据
	n, err := conn.Write([]byte("Hello Server"))
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	var buf [1024]byte
	//读取数据,返回读取的字节长度, 远程地址, err;示例中不用到远程地址,_忽略
	n, _, err = conn.ReadFromUDP(buf[0:])
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	fmt.Println(string(buf[0:n]))
}

#+END_SRC

* WEB编程
*** web程序
Go WEB程序以反向代理的方式发布.
+ func HandleFunc(partten string, handler func(ResponseWrite, *Request))
用来注册http路由的处理函数,partten是http的地址,handler是对应的处理函数.
+ func ListenAndServe(addr string, handler Handler) error
在指定端口监听HTTP请求,并阻塞程序,知道退出.
示例:
#+BEGIN_SRC go
package main

import (
	"net/http"
)

func main() {
	http.HandleFunc("/", HandleRequest)
	http.ListenAndServe(":8888", nil)
}

func HandleRequest(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("<h1>第一个web程序</h1"))
	w.Write([]byte(r.URL.Path))
}
#+END_SRC
编译运行,打开浏览器:http://127.0.0.1:8888/test

[[./firstweb.png]]
*** URL参数与Form表单处理
http.Request.URL.Query()可以获取地址栏中的参数,返回Values类型,
即map[string][]string
#+BEGIN_SRC go
package main

import (
	"fmt"
	"net/http"
)

func main() {
	http.HandleFunc("/", HandleRequest)
	http.ListenAndServe(":8888", nil)
}

func HandleRequest(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("<h1>第一个web程序</h1"))
	w.Write([]byte("\n<h1>URL参数</h1>"))
	w.Write([]byte(fmt.Sprintf("%v", r.URL.Query())))
	w.Write([]byte(r.URL.Path))
}
#+END_SRC
运行结果:

[[url.png]]

+ func (r *Request)ParseForm() error
解析URL请求的参数并更新r.Form

#+BEGIN_SRC go
package main

import (
	"fmt"
	"net/http"
)

func main() {
	http.HandleFunc("/", HandleRequest)
	http.ListenAndServe(":8888", nil)
}

func HandleRequest(w http.ResponseWriter, r *http.Request) {
	w.Header().Add("Content-Type", " text/html;charset=utf-8")
	if "POST" == r.Method {
		r.ParseForm()
		//FormValue("username")默认取出的是第一个
		w.Write([]byte("用户名: " + r.FormValue("username") + "<br/>"))
		w.Write([]byte("<hr/>"))
		names := r.Form["username"]
		w.Write([]byte("username 有两个: " + fmt.Sprintf("%v", names)))
		w.Write([]byte("<hr/>r.Form的内容: " + fmt.Sprintf("%v", r.Form)))
		w.Write([]byte("<hr/>r.PostForm的内容: " + fmt.Sprintf("%v", r.Form)))
	} else {
		strBody := `<form action="` + r.URL.RequestURI() + `" method="post">
用户名: <input name="username" type="text" /><br/>
用户名: <input name="username" type="text" /><br/>
<input type="submit" id="submit" value="submit">
</form>`
		w.Write([]byte(strBody))
		r.ParseForm()
	}
}
#+END_SRC
